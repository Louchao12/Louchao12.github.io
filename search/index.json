[{"content":"Java 基础 异常 运行时异常 继承RunTimeException 编译时异常 异常可以用throw关键字作为特定返回值\n当出现异常时，尝试解决异常\n一般来说，集中把异常抛出到最外层，最外层try catch。\nfinal 修饰类：不能被继承\n修饰方法：不能被重写 ，多用在抽象方法模板中\n修饰变量：这个变量一定要赋值且只能赋一次\n1. final 修饰引用类型的遍历，地址不能改变，但是内容可以改变 2. final 修饰基本数据类型 值不能被改变\nconstant 编译后会被宏替换，不会影响性能\n单例设计模式 饿汉式单例 懒汉式单例\n区别：延迟加载对象，饿汉式一旦用了单例类就创建对象，懒汉式只有调用了对象才开始创建对象\n枚举 1 2 3 4 修饰符 enum 枚举类名{ 名称1。。。 方法 } 可以用javap 用终端进行反编译\n用常量值和枚举做信息标志的区别：常量的参数值不受约束\n抽象类 抽象类可以写模板方法\n接口 接口里只能有常量和抽象方法\n接口是为了更好的解耦合\n区别\n代码块 静态代码块： 与类一起优先加载，对类进行初始化 static{}\n实例代码块： 每次创建对象就执行一次，和构造器一样对对象进行初始化{}\n匿名内部类 本质是一个子类也是一个子类对象\n会生成一个类，为类名$编号.class\n静态方法引用 作用：简化Lambda表达式\n格式：类名:: 静态方法；\n实例方法引用 用法： 对象名:: 实例方法\nAPI String Collection 并发修改异常\n在遍历的同时进行增删的操作\n解决方法：\n添加i\u0026ndash;; 逆序遍历 用迭代器方法remove()； 增强for和Lambda没办法解决这个问题 ArrayList 和LinkedList ArrayList 根据索引查询数据快\n特点\n默认数组大小是0，第一次添加数据进行扩容到10 后续每次扩容原数组的1.5倍 LinkedList底层是双链表\nMap 特点：无序，不重复，无索引，键和值都可以是null\n遍历\n1 2 3 4 5 Set\u0026lt;Map.Entry\u0026lt;String,Double\u0026gt;\u0026gt; entries = map.entrySet(); //java中将一个键值对封装为一个Entry对象进行遍历 map.forEach((k,v)-\u0026gt;sout(k+\u0026#34;=\u0026#34;+V)); //Lambda表达式遍历 map.put(k,map.containsKey(k)? map.get(k) + 1 : 1); Stream 准备数据源，获取Stream流，调用流水线的各种方法，获取处理结果\n可以用可变参数\n中间方法\n返回值是新流，可以链式编程\n终结方法\n收集stream流\n可变参数 IO流 注意事项\n编码解码 UTF-8中文是3个字节，英文和数字是1个字节\nGBK 中文是2 个字节，英文和数字是1个字节\n放入try中的，只能是资源，要继承closeable或autocloseable接口\ntry - with - resource\n文件的复制用字节流，文件的读写时用字符流\n缓存流 高级管道不支持追加，但是低级管道支持追究，可以使用高级管道包低级管道进行追加\n输入和输出的类型要一致\nIO框架 要导入Commons-io.jar\n线程 继承Thread，创建线程类的对象，重写run(), 启动start()（会自动调用run方法）\n可以用匿名内部类写法，也可以用Lambda表达式\nCallable Thread和Runnable都不能带返回值，重新call方法可以获取返回值\n初始化Callable实例\nFutureTask包住Callable实例\nThread包住FutureTask对象\nt.start\n通过FutureTask方法中的get方法获取返回值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.test.servers.servers.demo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class test { public static void main(String[] args) { FutureTask\u0026lt;String\u0026gt; future = new FutureTask\u0026lt;\u0026gt;(new MyCallable(100)); FutureTask\u0026lt;String\u0026gt; future2 = new FutureTask\u0026lt;\u0026gt;(new MyCallable(50)); Thread thread = new Thread(future); Thread thread2 = new Thread(future2); thread2.start(); thread.start(); try { System.out.println(future.get()); } catch (Exception e) { e.printStackTrace(); } try { System.out.println(future2.get()); } catch (Exception e) { e.printStackTrace(); } } } @Data @AllArgsConstructor @NoArgsConstructor class MyCallable implements Callable\u0026lt;String\u0026gt;{ private int num; @Override public String call() throws Exception { int sum = 0; for (int i = 1; i \u0026lt;= num; i++) { sum += i; } return \u0026#34;这是1-\u0026#34; + num + \u0026#34;的和：\u0026#34; + sum; } } API\n1 2 3 4 Thread.currentThread().getName()//哪个线程调用就获取哪个线程的名字 Thread thread2 = new Thread(future2,\u0026#34;二号线程\u0026#34;);//可以通过构造器设置线程的名字 Thread.sleep(1000);//休眠 t1.join();//插队 同步锁 synchronized（）{核心代码块}\n同步代码块性能比同步方法好，但是同步方法可读性更好\n1 private final lock lk = new ReentrantLock();//用final关键字保护锁 将解锁方式放在finally中更安全\n注意事项Runnable任务 处理Callable任务调用submit方法\n并发和并行 并发是指单核cpu轮询执行线程，但是由于速度快，就感觉是同时进行的\n并行是指多核cpu同时执行不同的线程\n执行任务中并发和并行是同时进行的\n网络编程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.test.servers.servers.demo2.net; import java.net.InetAddress; public class demon { public static void main(String[] args) { try { InetAddress ip = InetAddress.getLocalHost(); System.out.println(ip.getHostAddress()); System.out.println(ip.getHostName()); InetAddress ip2 = InetAddress.getByName(\u0026#34;www.google.com\u0026#34;); System.out.println(ip2.getHostAddress());//获取公网ip System.out.println(ip2.getHostName());//获取主机名 System.out.println(ip.isReachable(3000));//相当于ping命令 } catch (Exception e) { e.printStackTrace(); } } } UDP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //服务端 package com.test.servers.servers.demo2.udp; import java.net.*; public class Udp { public static void main(String[] args) throws Exception { //使用udp完成通信 DatagramSocket socket = new DatagramSocket();//创建套接字 byte[] bytes = \u0026#34;是韭菜\u0026#34; .getBytes(); /* * 参数一：发送数据 * 参数二：发送数据大小 * 参数三：目标IP * 参数四：目标端口*/ //创建数据包 DatagramPacket packet = new DatagramPacket(bytes, bytes.length, InetAddress.getLocalHost(),8080); socket.send(packet);//发送数据 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 客户端 package com.test.servers.servers.demo2.udp; import java.net.DatagramPacket; import java.net.DatagramSocket; public class UdpServices { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8080);// 监听端口 byte[] message = new byte[1024 * 64];// 创建一个缓冲区 DatagramPacket packet = new DatagramPacket(message, message.length);// 创建一个数据包，用于接收数据 socket.receive(packet);// 接收数据 int len = packet.getLength(); // 实际接收到的数据长度 String data = new String(message, 0, len); // 将接收到的数据转换为字符串 System.out.println(data); } } udp可以实现多发多收\nTCP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package com.test.servers.servers.demo2.tcp; import java.io.DataInputStream; import java.io.IOException; import java.io.InputStream; import java.net.Socket; public class ServerThread extends Thread { private Socket socket; public ServerThread(Socket socket) { this.socket = socket; } @Override public void run() { try(InputStream is = socket.getInputStream(); // 使用DataInputStream包装输入流，以便读取数据 DataInputStream in = new DataInputStream(is);) { // 读取客户端发送的整型ID和字符串消息 while (true) { int id = in.readInt(); String msg = in.readUTF(); // 打印接收到的ID和消息 System.out.println(\u0026#34;id \u0026#34;+ id + \u0026#34;msg \u0026#34; + msg); // 打印客户端的IP地址和端口号 System.out.println(\u0026#34;ip = \u0026#34; + socket.getInetAddress().getHostAddress()+\u0026#34;port=\u0026#34;+socket.getPort()); } } catch (IOException e) { System.out.println(\u0026#34;客户端下线 \u0026#34; + socket.getInetAddress().getAddress()); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.test.servers.servers.demo2.tcp; import java.io.*; import java.math.BigDecimal; import java.net.Socket; import java.util.Scanner; public class tcpClient { public static void main(String[] args) throws Exception { //用tcp实现客户端 System.out.println(\u0026#34;客户端启动\u0026#34;); // 创建Socket对象，连接本地主机的9999端口 Socket socket = new Socket(\u0026#34;127.0.0.1\u0026#34;,9999); // 创建Scanner对象，用于从控制台读取用户输入 Scanner in = new Scanner(System.in); // 获取Socket的输出流 OutputStream os = socket.getOutputStream(); // 创建DataOutputStream对象，用于发送数据到服务器 DataOutputStream out = new DataOutputStream(os); // 发送一个整数1到服务器，作为消息的标识 while (true) { // 提示用户输入消息 System.out.println(\u0026#34;请输入要发送的消息\u0026#34;); // 读取用户输入的消息 String msg = in.nextLine(); // 如果用户输入\u0026#34;exit\u0026#34;，关闭Socket连接并结束循环 if (msg.equals(\u0026#34;exit\u0026#34;)){ socket.close(); break; } out.writeInt(1); // 发送用户输入的消息到服务器 out.writeUTF(msg); out.flush();// 刷新输出流 } double a = 0.3; BigDecimal b = new BigDecimal(a);//不解决精度问题 BigDecimal c = new BigDecimal(a+\u0026#34;\u0026#34;);//解决精度问题，本质是字符串，底层是字符拆分 BigDecimal.valueOf(a);//解析字符串用的就是上面转字符串的方法 b.divide(c,2,BigDecimal.ROUND_HALF_UP);//四舍五入 } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.test.servers.servers.demo2.tcp; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class tcpServices { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;tcp服务端\u0026#34;); // 创建ServerSocket实例，监听9999端口 ServerSocket ss = new ServerSocket(9999); // 等待客户端连接，接收到连接请求后创建Socket对象 while (true) { Socket socket = ss.accept(); System.out.println(\u0026#34;客户端连接成功\u0026#34; + socket.getInetAddress().getAddress()); new ServerThread(socket).start(); // 无限循环以持续处理客户端请求 } } } 线程池优化通信 String 拼接优化 用传统的“+”拼接十分耗时，因为String是不可变对象，修改数据性能很差\n1 2 3 4 5 6 StringBuilder sb = new StringBuilder(); for(int i = 0; i \u0026lt; 1000000; i++){ sb.append(\u0026#34;abc\u0026#34;); } Sytem.out.println(sb); String s = sb.toString() StringBuilder 可以支持链式编程 ，但是最后要转成String返回；\nBigDecimal() 解决小数计算精度问题\n二进制表示的局限性： 浮点数在计算机中是以二进制形式存储的，而某些十进制小数无法精确地表示为二进制小数。例如，十进制的 0.1 在二进制中是一个无限循环小数 0.0001100110011\u0026hellip;。由于浮点数的存储空间有限，这些无限循环小数在存储时会被截断，导致精度损失。 IEEE 754 标准： 浮点数遵循 IEEE 754 标准，该标准定义了浮点数的存储格式，包括单精度（32位）和双精度（64位）。单精度浮点数（float）有23位尾数（小数部分），双精度浮点数（double）有52位尾数。即使这样，也无法精确表示所有十进制小数。 1 2 3 4 5 6 double a = 0.3; BigDecimal b = new BigDecimal(a);//不解决精度问题 BigDecimal c = new BigDecimal(a+\u0026#34;\u0026#34;);//解决精度问题，本质是字符串，底层是字符拆分 BigDecimal.valueOf(a);//解析字符串用的就是上面转字符串的方法 BigDecimal.divide() b.divide(c,2,BigDecimal.ROUND_HALF_UP);//精确位数 四舍五入 JUNIT 要做断言测试测试API\u0026ndash;Assert\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.test.servers.servers.junit; public class function { //获取一个字符串的长度 public static int getLength(String str){ int length = 0; if(str == null || str.isEmpty()){ return 0; } char[] chars = str.toCharArray(); return chars.length; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.test.servers.servers.junit; import org.junit.Assert; import org.junit.Test; public class getLengthTest { @Test public void testGetLength() { String str = \u0026#34;hello world\u0026#34;; String str1 = null; Assert.assertEquals(\u0026#34;正常输入\u0026#34;,11, function.getLength(str)); Assert.assertEquals(\u0026#34;空字符串\u0026#34;,0, function.getLength(str1)); } } 反射 反射主要是制作框架用的，可以通过暴力反射直接获取private属性的对象或方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 package com.test.servers.servers.reflect; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.util.ArrayList; public class reflectDemo { public static void main(String[] args) throws Exception { // 获取Agent类的Class对象 Class c = Agent.class; // 打印类的全名 System.out.println(c.getName()); // 打印类的简单名 System.out.println(c.getSimpleName()); // 获取Agent类的所有构造器 Constructor[] con = c.getDeclaredConstructors(); // 获取Agent类的指定构造器 Constructor con1 = c.getDeclaredConstructor(String.class, ArrayList.class, double.class); // 设置构造器可访问，以便反射调用 con1.setAccessible(true); // 使用反射通过构造器创建Agent对象 Agent A = (Agent) con1.newInstance(\u0026#34;小明\u0026#34;, new ArrayList\u0026lt;Integer\u0026gt;(), 1); // 打印有参构造器创建的Agent对象 System.out.println(A); // 打印有参构造器的信息 System.out.println(\u0026#34;有参构造器\u0026#34; + con1.getDeclaringClass().getSimpleName() + con1.getParameterCount()); // 遍历并打印所有构造器的信息 for (Constructor constructor : con) { System.out.println(constructor.getDeclaringClass().getSimpleName() + constructor.getParameterCount()); } // 获取Agent类的所有属性 Field[] fields = c.getDeclaredFields(); // 遍历并打印所有属性的名称 for (Field field : fields) { System.out.println(field.getName()); } // 获取Agent类的指定属性 Field field1 = c.getDeclaredField(\u0026#34;name\u0026#34;); // 打印属性的名称和类型 System.out.println(field1.getName() + field1.getType()); // 获取Agent类的所有方法 Method[] methods = c.getDeclaredMethods(); // 遍历并打印所有方法的名称和参数数量 for (Method method : methods) { System.out.println(method.getName() + method.getParameterCount()); } // 获取Agent类的指定方法 Method method1 = c.getDeclaredMethod(\u0026#34;sort\u0026#34;); // 获取Agent类的重载方法 Method method2 = c.getDeclaredMethod(\u0026#34;sort\u0026#34;, String.class); // 设置方法可访问，以便反射调用 method1.setAccessible(true); // 使用反射调用方法 method1.invoke(A); // 获取Agent类的无参构造器 Constructor con2 = c.getDeclaredConstructor(); // 使用反射通过无参构造器创建Agent对象 Agent agent = (Agent) con2.newInstance(); // 获取Agent类的指定属性并设置可访问 Field field2 = c.getDeclaredField(\u0026#34;name\u0026#34;); field2.setAccessible(true); // 使用反射修改属性值 field2.set(agent, \u0026#34;AgentB\u0026#34;); // 打印修改属性值后的Agent对象 System.out.println(agent); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.test.servers.servers.reflect; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; import java.util.ArrayList; public class Agent { private String name; private ArrayList\u0026lt;Integer\u0026gt; prefect; private double value; public Agent(){ System.out.println(\u0026#34;无参构造器启动\u0026#34;); } private Agent(String name, ArrayList\u0026lt;Integer\u0026gt; prefect, double value){ this.name = name; this.prefect = prefect; this.value = value; System.out.println(\u0026#34;有参构造器启动\u0026#34;); } private String sort(){ return \u0026#34;这是sort方法\u0026#34;; } private String sort(String name){ return \u0026#34;这是sort方法，参数为：\u0026#34;+name; } private String dance(String name, ArrayList\u0026lt;Integer\u0026gt; prefect){ this.prefect = prefect; return \u0026#34;name:\u0026#34;+name+\u0026#34; prefect:\u0026#34;+prefect; } public String toString(){ return \u0026#34;name:\u0026#34;+name+\u0026#34; prefect:\u0026#34;+prefect; } } 注解 注解中仅有value值 ，可以不写value直接赋值，但是如果有其他属性且无默认值则不能省略。\n元注解\n动态代理 动态代理概述 动态代理是一种在运行时创建一个实现接口的代理对象的技术。Java 提供了 java.lang.reflect.Proxy 类来实现动态代理。动态代理主要应用于 AOP（面向切面编程）、日志记录、权限控制等场景。\n原代码中的动态代理应用 假设我们需要为 demo2 类中的 f 方法添加日志记录功能，可以使用动态代理来实现。以下是详细的步骤和代码示例：\n1. 定义接口 首先，定义一个接口，该接口包含 f 方法。\n1 2 3 public interface DemoInterface { int f(int n, ArrayList\u0026lt;Integer\u0026gt; list); } 2. 实现接口 实现上述接口，将 demo2 类中的 f 方法移到实现类中。\n1 2 3 4 5 6 7 8 9 10 11 12 public class DemoImpl implements DemoInterface { @Override public int f(int n, ArrayList\u0026lt;Integer\u0026gt; list) { if (n == 1) { return list.get(0); } for (int i = 0; i \u0026lt; n; i++) { if (n % 2 == 1) { list.remove(i); } } return f(n / 2, list); } } 3. 创建动态代理类 使用 Proxy 类创建动态代理对象，并在调用方法时添加日志记录功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class DemoProxy implements InvocationHandler { private final DemoInterface demoInterface; public DemoProxy(DemoInterface demoInterface) { this.demoInterface = demoInterface; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;Before method: \u0026#34; + method.getName()); Object result = method.invoke(demoInterface, args); System.out.println(\u0026#34;After method: \u0026#34; + method.getName()); return result; } public static DemoInterface createProxy(DemoInterface demoInterface) { return (DemoInterface) Proxy.newProxyInstance( demoInterface.getClass().getClassLoader(), demoInterface.getClass().getInterfaces(), new DemoProxy(demoInterface) ); } } 4. 修改主类 在主类中使用动态代理对象调用 f 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import java.util.*; public class demo2 { public static void main(String[] args) { Set\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); while (set.size() \u0026lt; 100) { set.add(ThreadLocalRandom.current().nextInt(1, 201)); } // 将set转成list ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(set); Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; list.size(); i++) { map.put(list.get(i), i); } int len = list.size(); // 创建动态代理对象 DemoInterface demoInterface = new DemoImpl(); DemoInterface proxy = DemoProxy.createProxy(demoInterface); int n = proxy.f(len, list); System.out.println(\u0026#34;最后一个数\u0026#34; + n + \u0026#34;初始位置\u0026#34; + map.get(n)); } } 总结 通过以上步骤，我们成功地为 demo2 类中的 f 方法添加了日志记录功能，而无需修改原始方法的实现。动态代理的灵活性和扩展性使得它在实际开发中非常有用。\n","date":"2024-11-27T14:24:57+08:00","image":"https://Louchao12.github.io/p/java-%E5%9F%BA%E7%A1%80/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://Louchao12.github.io/p/java-%E5%9F%BA%E7%A1%80/","title":"Java 基础"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://Louchao12.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://Louchao12.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://Louchao12.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://Louchao12.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://Louchao12.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://Louchao12.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://Louchao12.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://Louchao12.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://Louchao12.github.io/p/emoji-support/","title":"Emoji Support"}]